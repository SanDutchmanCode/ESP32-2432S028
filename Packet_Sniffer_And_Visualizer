#include <TFT_eSPI.h>
#include "esp_wifi.h"
#include "esp_wifi_types.h"
#include "esp_system.h"
#include "esp_event.h"
#include "nvs_flash.h"
#include "esp_netif.h"
#include <string.h>
#include <math.h>

// Initialiseer het TFT-scherm
TFT_eSPI screen = TFT_eSPI();

// Schermparameters
#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 240
#define LEGEND_HEIGHT 20
#define BAR_CHART_HEIGHT 100
#define LOG_HEIGHT 120

// Staafdiagram-instellingen
#define MAXIMUM_PACKET_SIZE 1500 // Maximale grootte van een typisch pakket
#define NUMBER_OF_BARS 20 // Aantal staven in het diagram
int packetSizes[NUMBER_OF_BARS] = {0};
int packetTypes[NUMBER_OF_BARS] = {0}; // 0=Onbekend, 1=Management, 2=Control, 3=Data

// Log-instellingen
#define LOG_LINES 3 // Toon 3 pakketten, elk met 3 regels
#define LOG_BUFFER_SIZE (LOG_LINES * 3) // Buffer voor drie regels per pakket
String logBuffer[LOG_BUFFER_SIZE];
int logIndex = 0;

// Vlag om aan te geven wanneer de grafiek en log geÃ¼pdatet moeten worden
volatile bool newDataAvailable = false;

// Wi-Fi-pakketheader structuur (802.11)
typedef struct {
    uint8_t frame_control[2];
    uint8_t duration_id[2];
    uint8_t addr1[6]; // Destination MAC
    uint8_t addr2[6]; // Source MAC
    uint8_t addr3[6]; // Transmitter/Receiver MAC
    uint8_t sequence_control[2];
    uint8_t addr4[6];
    uint8_t qos_control[2];
    uint8_t ht_control[4];
    uint8_t llc_header[6];
    uint8_t type_ethernet[2];
} wifi_ieee80211_mac_hdr_ext_t;

// IP-pakketheader structuur
typedef struct {
    uint8_t ip_ihl_ver;
    uint8_t ip_tos;
    uint16_t ip_len;
    uint16_t ip_id;
    uint16_t ip_off;
    uint8_t ip_ttl;
    uint8_t ip_p;
    uint16_t ip_sum;
    uint8_t ip_src[4];
    uint8_t ip_dst[4];
} ip_header_t;

// Functie om het Wi-Fi-pakkettype te bepalen
String getPacketType(uint8_t type, uint8_t subtype) {
    switch (type) {
        case 0: // Management Frame
            switch (subtype) {
                case 0:  return "Assoc. Req";
                case 1:  return "Assoc. Resp";
                case 4:  return "Probe Req";
                case 5:  return "Probe Resp";
                case 8:  return "Beacon";
                case 10: return "Disassoc";
                case 11: return "Auth";
                case 12: return "Deauth";
                default: return "Mgmt " + String(subtype);
            }
        case 1: // Control Frame
            switch (subtype) {
                case 8:  return "Block Ack Req";
                case 9:  return "Block Ack";
                case 10: return "PS-Poll";
                case 11: return "RTS";
                case 12: return "CTS";
                case 13: return "ACK";
                case 14: return "CF-End";
                case 15: return "CF-End+ACK";
                default: return "Ctrl " + String(subtype);
            }
        case 2: // Data Frame
            return "Data";
        default:
            return "Unknown";
    }
}

// Functie om de staafkleur te bepalen op basis van het pakkettype
uint16_t getBarColor(uint8_t type) {
    switch (type) {
        case 1: return TFT_YELLOW; // Management
        case 2: return TFT_CYAN;   // Control
        case 3: return TFT_GREEN;  // Data
        default: return TFT_RED;    // Onbekend
    }
}

// Hulpfunctie om MAC-adressen te formatteren
void mac_to_string(char *str, const uint8_t *addr) {
    sprintf(str, "%02X:%02X:%02X:%02X:%02X:%02X", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
}

// Functie voor de promiscuous mode
void packetHandler(void* buf, wifi_promiscuous_pkt_type_t type) {
    wifi_promiscuous_pkt_t *packet = (wifi_promiscuous_pkt_t*)buf;
    int size = packet->rx_ctrl.sig_len;
    
    uint8_t barType = 0;
    String logLine1 = "N/A";
    String logLine2 = "N/A";
    String logLine3 = "N/A";

    if (size > 26) {
        uint8_t frame_control = packet->payload[0];
        uint8_t packet_type = (frame_control & 0b00001100) >> 2;
        uint8_t packet_subtype = (frame_control & 0b11110000) >> 4;
        
        String type_string = getPacketType(packet_type, packet_subtype);
        
        if (packet_type == 0) barType = 1; 
        else if (packet_type == 1) barType = 2; 
        else if (packet_type == 2) barType = 3; 

        uint8_t *source_mac = (uint8_t *)packet->payload + 10;
        uint8_t *dest_mac = (uint8_t *)packet->payload + 4;

        char src_mac_str[18], dst_mac_str[18];
        mac_to_string(src_mac_str, source_mac);
        mac_to_string(dst_mac_str, dest_mac);

        // Stel de logregels in
        logLine1 = "Destination MAC   : " + String(dst_mac_str);
        logLine2 = "Source MAC        : " + String(src_mac_str);
        logLine3 = "Packet Type & Size: " + type_string + " - " + String(size) + "B";
    } else {
        logLine1 = "Unknown destination";
        logLine2 = "Unknown source";
        logLine3 = "Size: " + String(size) + "B";
    }
    
    for (int i = 0; i < NUMBER_OF_BARS - 1; i++) {
        packetSizes[i] = packetSizes[i + 1];
        packetTypes[i] = packetTypes[i + 1];
    }
    packetSizes[NUMBER_OF_BARS - 1] = size;
    packetTypes[NUMBER_OF_BARS - 1] = barType;

    logBuffer[logIndex] = logLine1;
    logIndex = (logIndex + 1) % LOG_BUFFER_SIZE;
    logBuffer[logIndex] = logLine2;
    logIndex = (logIndex + 1) % LOG_BUFFER_SIZE;
    logBuffer[logIndex] = logLine3;
    logIndex = (logIndex + 1) % LOG_BUFFER_SIZE;
    
    newDataAvailable = true;
}

// Functie om het staafdiagram te tekenen
void drawBarChart() {
    screen.fillRect(30, LEGEND_HEIGHT, SCREEN_WIDTH - 30, BAR_CHART_HEIGHT, TFT_BLACK); 
    int barWidth = (SCREEN_WIDTH - 30) / NUMBER_OF_BARS;
    for (int i = 0; i < NUMBER_OF_BARS; i++) {
        int barHeight = map(packetSizes[i], 0, MAXIMUM_PACKET_SIZE, 0, BAR_CHART_HEIGHT - 10);
        screen.fillRect(30 + i * barWidth + 1, LEGEND_HEIGHT + BAR_CHART_HEIGHT - barHeight, barWidth - 2, barHeight, getBarColor(packetTypes[i]));
    }
}

// Functie om de activiteit te loggen
void drawLog() {
    screen.fillRect(0, LEGEND_HEIGHT + BAR_CHART_HEIGHT + 1, SCREEN_WIDTH, LOG_HEIGHT, TFT_DARKGREY);
    screen.setTextColor(TFT_WHITE);
    screen.setTextSize(1);
    
    for (int i = 0; i < LOG_BUFFER_SIZE; i++) {
        int logLineIndex = (logIndex - 1 - i + LOG_BUFFER_SIZE) % LOG_BUFFER_SIZE;
        screen.setCursor(5, LEGEND_HEIGHT + BAR_CHART_HEIGHT + 5 + (i * 12));
        screen.println(logBuffer[logLineIndex]);
    }
}

// Functie om de legenda te tekenen
void drawLegend() {
    screen.fillRect(0, 0, SCREEN_WIDTH, LEGEND_HEIGHT, TFT_NAVY);
    screen.setTextColor(TFT_WHITE);
    screen.setTextSize(1);
    
    int x_position = 5;
    
    screen.fillRect(x_position, 5, 10, 10, TFT_YELLOW);
    screen.setCursor(x_position + 12, 5);
    screen.print("Management");
    x_position += 100;

    screen.fillRect(x_position, 5, 10, 10, TFT_CYAN);
    screen.setCursor(x_position + 12, 5);
    screen.print("Control");
    x_position += 70;

    screen.fillRect(x_position, 5, 10, 10, TFT_GREEN);
    screen.setCursor(x_position + 12, 5);
    screen.print("Data");
    x_position += 50;
    
    screen.fillRect(x_position, 5, 10, 10, TFT_RED);
    screen.setCursor(x_position + 12, 5);
    screen.print("Unknown");
}

// Functie om de Y-as labels eenmalig te tekenen
void drawYAxisLabels() {
    screen.setTextColor(TFT_WHITE);
    screen.setTextSize(1);
    
    screen.setCursor(0, LEGEND_HEIGHT + BAR_CHART_HEIGHT - 10);
    screen.println("0");
    screen.drawFastHLine(25, LEGEND_HEIGHT + BAR_CHART_HEIGHT - 5, 5, TFT_WHITE);
    
    screen.setCursor(0, LEGEND_HEIGHT + BAR_CHART_HEIGHT / 4 * 3 - 5);
    screen.println("500");
    screen.drawFastHLine(25, LEGEND_HEIGHT + BAR_CHART_HEIGHT / 4 * 3, 5, TFT_WHITE);

    screen.setCursor(0, LEGEND_HEIGHT + BAR_CHART_HEIGHT / 2 - 5);
    screen.println("1000");
    screen.drawFastHLine(25, LEGEND_HEIGHT + BAR_CHART_HEIGHT / 2, 5, TFT_WHITE);

    screen.setCursor(0, LEGEND_HEIGHT + BAR_CHART_HEIGHT / 4 - 5);
    screen.println("1500");
    screen.drawFastHLine(25, LEGEND_HEIGHT + BAR_CHART_HEIGHT / 4, 5, TFT_WHITE);
}

void setup() {
    Serial.begin(115200);

    screen.init();
    screen.setRotation(3);
    screen.fillScreen(TFT_BLACK);

    drawLegend(); 
    drawYAxisLabels(); 

    screen.drawFastHLine(0, LEGEND_HEIGHT + BAR_CHART_HEIGHT, SCREEN_WIDTH, TFT_BLACK);

    esp_err_t errorCode = nvs_flash_init();
    if (errorCode == ESP_ERR_NVS_NO_FREE_PAGES || errorCode == ESP_ERR_NVS_NOT_INITIALIZED) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        errorCode = nvs_flash_init();
    }
    ESP_ERROR_CHECK(errorCode);

    esp_netif_init();
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    wifi_init_config_t configuration = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&configuration));
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    ESP_ERROR_CHECK(esp_wifi_set_promiscuous(true));
    ESP_ERROR_CHECK(esp_wifi_set_promiscuous_rx_cb(&packetHandler));
    ESP_ERROR_CHECK(esp_wifi_start());

    screen.setCursor(0, LEGEND_HEIGHT + BAR_CHART_HEIGHT + 10);
    screen.println("Waiting for packets...");
}

void loop() {
    if (newDataAvailable) {
        drawBarChart();
        drawLog();
        newDataAvailable = false;
    }
    delay(10);
}
